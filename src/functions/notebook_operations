class DataPlotter:
    
    def loop_name_finder(INPUTNAME):
        SEGMENTS = INPUTNAME.split(" ")
        NAME=[]
        for SEG in SEGMENTS:
            # print(SEG)
            if len(SEG) > 2 and SEG.lower() not in ['van'] and not SEG[0].isupper():
                SEG=SEG.title()
            # print(SEG)
            NAME.append(SEG)
        NAME = ' '.join(NAME)
        # print(NAME)
        SOURCEFILE = DataTransformer.all_df.player.tolist()
        while NAME not in SOURCEFILE:
            M1 = difflib.get_close_matches(INPUTNAME, SOURCEFILE)
            STRS = INPUTNAME.split(" ")
            M2 = []
            for STR in STRS:
                if len(STR) < 3:
                    continue
                for CSV_NAME in SOURCEFILE:
                    CSV_ALT = ''.join(c for c in unicodedata.normalize('NFD', CSV_NAME)
                                      if unicodedata.category(c) != 'Mn')
                    if STR.lower() in CSV_ALT.lower():
                        M2.append(CSV_NAME)
            NAME = input(f'Couldnt find "{NAME}", did you mean any of the following?\n{list(set(M1) | set(M2))}\n')
            if NAME == "":
                return NAME
        return NAME

    def fetch_team_color(team_id):
        team_colors = {
            1: '#DE0202',   # Arsenal
            2: '#75AADB',   # Aston Villa
            3: '#DA291C',   # Bournemouth
            4: '#FDB913',   # Brentford
            5: '#0057B8',   # Brighton & Hove Albion
            6: '#FFD700',   #Burnley
            7: '#034694',   # Chelsea
            8: '#1B458F',   # Crystal Palace
            9: '#003399',   # Everton
            10: '#F5A646',  # Fulham
            11: '#C8102E',  # Liverpool
            12: '#0053A0',  # Luton Town
            13: '#6CABDD',  # Manchester City
            14: '#DA291C',  # Manchester United
            15: '#241F20',  # Newcastle United
            16: '#BD1E2C',  # Nottingham Forest
            17: '#D71920',  # Sheffield United
            18: '#001C58',  # Tottenham Hotspur
            19: '#7A263A',  # West Ham United
            20: '#FDB913'   # Wolverhampton Wanderers
        }
        return team_colors[team_id]

    @classmethod
    def plot_multi_stats(self,param,dataset,values,remove_FPL15 = False):
        df = DataTransformer.all_df
        if param not in df.columns:
            print(f"Incorrect 'param' format, should be one of: {list(df.columns)}")
            return
        if dataset in ['specialized','myteam']:
            if dataset == 'specialized':
                pos = values[0]
                lookback = values[1]
                num_players = values[2]
                df = df.loc[df['position'] == pos]
                if remove_FPL15:
                    df = df.loc[~df['id_player'].isin(MyTeam.df_fpl.id.to_list())]
            elif dataset == 'myteam':
                pos = values[0]
                lookback = 6
                df = df.loc[(df['id_player'].isin(MyTeam.df_fpl.id.to_list())) & (df['position'] == pos)]
                num_players = len(df)
        def average_last(lst):
            return sum(lst[-lookback:]) / lookback
        df[f"{param}_avg"] = df.apply(lambda x: average_last(x[param]), axis = 1)
        df_sorted = df.sort_values(by=f"{param}_avg", ascending=False).head(num_players)
        data = df_sorted[['id_player','player','round',param,f"{param}_avg"]]
        data = data.reset_index(drop = True)
        num_cols = min(7,len(data))
        num_rows = (len(data) + 2) // num_cols
        fig = make_subplots(rows=num_rows, cols=num_cols, subplot_titles=data['player'].tolist())
        for i, d in data.iterrows():
            row = i // num_cols + 1
            col = i % num_cols + 1
#             print(f"{row} {col}")
            color = self.fetch_team_color(GrabFunctions.grab_player_team_id(d['id_player']))
            team = GrabFunctions.grab_player_team(d['id_player'])
            fig.add_trace(go.Scatter(x=d['round'], y=d[param], name = team, mode="markers+lines", line=dict(color=color), marker=dict(color=color)), row=row, col=col)
            fig.update_xaxes(title_text='GW', row=row, col=col)
            if param == 'history':
                fig.add_hrect(y0=-1, y1=4, line_width=0, fillcolor="red", opacity=0.2, row=row, col=col)
                fig.add_hrect(y0=4, y1=6, line_width=0, fillcolor="yellow", opacity=0.2, row=row, col=col)
                fig.add_hrect(y0=6, y1=9, line_width=0, fillcolor="green", opacity=0.2, row=row, col=col)
                fig.add_hrect(y0=9, y1=max(d[param])+2, line_width=0, fillcolor="blue", opacity=0.2, row=row, col=col)
            else:
                fig.add_hline(y=d[f"{param}_avg"], line_dash='dot', line_width=2, line_color='black', row=row, col=col)
            fig.update_xaxes(nticks = 6, row=row, col=col)
            fig.update_yaxes(nticks = 6, row=row, col=col)
        fig.update_layout(height=350*(num_rows), width=350*num_cols)
        fig.update_layout(title=f'{param} vs GW',showlegend=False)
        fig.update_xaxes(title='GW')
        fig.update_yaxes(title=param)
        fig.show()
        return
    
    @classmethod
    def plot_individual_stats(self,player_name,paramlist):
        return

class DecisionMatrix:
    
    @classmethod
    def initialize_players(self):
        self.players=[]
        for num in DataTransformer.all_df.id_player.tolist():
            df = FPLDatabase.total_summary.loc[FPLDatabase.total_summary['id_player'] == num]
#             print(df.columns.to_list())
            position = df['position'].iloc[0]
            history = df['history'].iloc[0]
            bps = df['bps'].iloc[0]
            ICT = df['ict_index'].iloc[0]
            xGI = df['expected_goal_involvements'].iloc[0]
            minutes = df['minutes'].iloc[0]
            xGC = df['expected_goals_conceded'].iloc[0]
            cost = df['changing_value'].iloc[0][-1]
            if position in ['DEF','GKP']:
                self.players.append({'id':num,'position':position,'name':GrabFunctions.grab_player_name(num), 'history':(np.mean(history[-6:]),history[-6:]), 'bps':(np.mean(bps[-6:]),bps[-6:]), 'ict':(np.mean(ICT[-6:]),ICT[-6:]), 'xGI':(np.mean(xGI[-6:]),xGI[-6:]), 'xGC':(np.mean(xGC[-6:]),xGC[-6:]), 'minutes':minutes[-6:], 'cost':cost/10})
            else:
                self.players.append({'id':num,'position':position,'name':GrabFunctions.grab_player_name(num), 'history':(np.mean(history[-6:]),history[-6:]), 'bps':(np.mean(bps[-6:]),bps[-6:]), 'ict':(np.mean(ICT[-6:]),ICT[-6:]), 'xGI':(np.mean(xGI[-6:]),xGI[-6:]), 'minutes':minutes[-6:], 'cost':cost/10})
       
    @classmethod
    def initialize_replacements(self):
        player_dict = {}
        for param,param_thresh in [('ict_index',7),('returnhist',1),('bps',25),('expected_goal_involvements',0.75),('history',6)]:
#             param = 'ict_index'
#             param_thresh = 5
            player_dict[param] = {}
            for look_back in [1,2,3,4,5,6]:
                df = DataTransformer.all_df
                FPL_15_players = MyTeam.df_fpl.id.tolist()
                mask = df.id_player.isin(FPL_15_players)
                df = df[~mask]
                pristine_df = df.copy()
                def last_3_values(lst):
                    return np.mean(lst[-look_back:])
                mask = df[param].apply(last_3_values) >= param_thresh
                df = df[mask]
                grouped = df.groupby('position').apply(lambda x: x.sort_values('position')).reset_index(drop=True)
                grouped_dict = {group: group_df for group, group_df in grouped.groupby('position')}
                player_dict[param][look_back] = {}
                for position in ['DEF','MID','FWD']:
                    try:
                        df = grouped_dict[position]
                        df_sorted = df.sort_values(by=param, key=lambda x: x.map(last_3_values), ascending = False)
                        player_dict[param][look_back][position] = df_sorted.id_player.tolist()
#                         # Loop through every 2,3,4 values
#                         if look_back in [2,3,4]:
#                             print(look_back)
#                             for i in range(0, len(df[param]), look_back):
#                                 if i + look_back - 1 < len(df[param]):
#                                     avg_value = np.mean(df[param][i:i+look_back])
# #                                     if avg_value >= param_thresh:
#                                     print(avg_value)
                    except:
                        pass

        unique_values = {
            'DEF': [],
            'MID': [],
            'FWD': []
        }
#         print(player_dict)
        # Iterate over the values in the inner dictionaries and update the unique_values dictionary
        for param in player_dict.keys():
            for d in player_dict[param].values():
                for k, v in d.items():
                    unique_values[k].extend(v)

        # Extract the unique values for each group
        unique_values['DEF'] = list(set(unique_values['DEF']))
        unique_values['MID'] = list(set(unique_values['MID']))
        unique_values['FWD'] = list(set(unique_values['FWD']))
        # print(unique_values)
        self.replacement_players=[]
        def passes_xGI_threshold(numbers):
            if len(numbers) >= 3:
                last_three = numbers[-3:]
                combinations = [(last_three[0], last_three[1]),
                                (last_three[0], last_three[2]),
                                (last_three[1], last_three[2])]

                for a, b in combinations:
                    average = (a + b) / 2
                    if average > 0.5:
                        return True

            return False
        for key in unique_values.keys():
        #     print(f'\n{key}\n')
            for num in unique_values[key]:
                df = FPLDatabase.total_summary.loc[FPLDatabase.total_summary['id_player'] == num]
                history = df['history'].iloc[0]
                bps = df['bps'].iloc[0]
                ICT = df['ict_index'].iloc[0]
                xGI = df['expected_goal_involvements'].iloc[0]
                xGC = df['expected_goals_conceded'].iloc[0]
                mins = df['minutes'].iloc[0]
                cost = df['changing_value'].iloc[0][-1]
                if key == 'DEF':
        #             print(f'{GrabFunctions.grab_player_name(num)} (${cost/10})')
                    self.replacement_players.append({'id':num,'position':key,'name':GrabFunctions.grab_player_name(num), 'history':(np.mean(history[-6:]),history[-6:]), 'bps':(np.mean(bps[-6:]),bps[-6:]), 'ict':(np.mean(ICT[-6:]),ICT[-6:]), 'xGI':(np.mean(xGI[-6:]),xGI[-6:]), 'xGC':(np.mean(xGC[-6:]),xGC[-6:]), 'minutes':mins[-6:],'cost':cost/10})
                else:
                    if np.mean(xGI[-6:]) > 0.4 or passes_xGI_threshold(xGI):
        #                 print(f'{GrabFunctions.grab_player_name(num)} {xGI[-6:]} (${cost/10})')
                        self.replacement_players.append({'id':num,'position':key,'name':GrabFunctions.grab_player_name(num), 'history':(np.mean(history[-6:]),history[-6:]), 'bps':(np.mean(bps[-6:]),bps[-6:]), 'ict':(np.mean(ICT[-6:]),ICT[-6:]), 'xGI':(np.mean(xGI[-6:]),xGI[-6:]), 'minutes':mins[-6:],'cost':cost/10})
        players = [x for x in self.players if x['id'] in MyTeam.df_fpl['id'].to_list()]    
        combinations = [(dict1, dict2) for dict1, dict2 in itertools.product(players, self.replacement_players) if ((dict2['ict'][0]+1 > dict1['ict'][0]) and dict2['position'] == dict1['position'])]
        self.my_dict = {}
        for key, value in combinations:
            if key['name'] in self.my_dict:
                self.my_dict[key['name']]['replacement'].append((value,round(value['cost']-key['cost'],2)))
            else:
                self.my_dict[key['name']] = {'stats':key,'replacement':[(value,round(value['cost']-key['cost'],2))]}
        seq_map = {'GKP':0, 'DEF':1, 'MID':2, 'FWD':3}
        items = sorted(DecisionMatrix.my_dict.items(), key=lambda x: seq_map[x[1]['stats']['position']])
        self.my_dict = {k:v for k,v in items}
        
    @classmethod
    def initialize_effective_ownership(self):    
        RIVALS_INIT = [782655,#Just Quiet
                       467038,#GreatestShow
                       'genius']
        counter_dict = {}
        #Find IDs with ranks
        def rank_finder(ID):
            r = requests.get(
                            'https://fantasy.premierleague.com/api/entry/' + str(ID) + '/event/' + str(FPLDatabase.LATEST_GW) + '/picks/'
                    ).json()
            return r['entry_history']['overall_rank']
        top_1k = [idx for idx in FPLDatabase.GENIUS_IDS if rank_finder(idx) <= 1000]
        top_10k = [idx for idx in FPLDatabase.GENIUS_IDS if rank_finder(idx) <= 10000]
        top_100k = [idx for idx in FPLDatabase.GENIUS_IDS if rank_finder(idx) <= 100000]
        rank_dict={}
        for topper,namer in [(top_1k,'gen_1k'), (top_10k,'gen_10k'), (top_100k,'gen_100k')]:
#             if topper:
#                 if (namer == 'gen_10k' and len(top_10k) == len(top_1k)) or (namer == 'gen_100k' and len(top_100k) == len(top_10k)):
#                     continue
#                 else:
            RIVALS_INIT.append(namer)
            rank_dict[namer] = topper
        def dict_counter(dictx, listx, rivalx):
            for idx in listx:
                if idx not in dictx[rivalx]['players'].keys():
                    dictx[rivalx]['players'][idx] = 1
                else:
                    dictx[rivalx]['players'][idx] += 1
            return
        for RIVAL_LEAGUE in RIVALS_INIT:
            if 'gen' not in str(RIVAL_LEAGUE):
                base_url = 'https://fantasy.premierleague.com/api/' + 'leagues-classic/' + str(RIVAL_LEAGUE) + '/standings/'
                league_r = requests.get(base_url).json()
                league_players = league_r['standings']['results']
                my_rank,my_points = [(x['rank'],x['total']) for x in league_players if x['player_name'] == 'Javaid Baksh'][0]
                players_of_interest = [x['entry'] for x in league_players if ((x['rank'] < my_rank) or (x['total'] > my_points - 50 and x['rank'] > my_rank))]
            elif RIVAL_LEAGUE == 'genius':
                players_of_interest = FPLDatabase.GENIUS_IDS
#             print(players_of_interest)
            elif 'gen_' in RIVAL_LEAGUE:
                players_of_interest = rank_dict[RIVAL_LEAGUE]
            counter_dict[RIVAL_LEAGUE] = {'rivals':len(players_of_interest),'players':{}}
            for RIVAL_ID in players_of_interest:
                url = 'https://fantasy.premierleague.com/api/' + 'entry/' + str(RIVAL_ID) + '/event/' + str(FPLDatabase.LATEST_GW) + '/picks/'
                r = requests.get(url).json()
                player_ids = [x['element'] for x in r['picks']]
                dict_counter(counter_dict, player_ids, RIVAL_LEAGUE)
            counter_dict[RIVAL_LEAGUE]['players'] = dict(sorted(counter_dict[RIVAL_LEAGUE]['players'].items(), key=lambda item: item[1], reverse=True))
        self.eff_own_dict = counter_dict
    
    @classmethod
    def get_ownership(self,player_id,league_id,format_color):
        ids = self.eff_own_dict[league_id]
        total_rivals = ids['rivals']
        total_players = ids['players']
        if player_id not in total_players.keys():
            count = 0
        else:
            count = total_players[player_id]
        if count == 0 and format_color == 'sell':
            count_str = "\033[31m" +  str(count) + "\033[0m"
        elif count != 0 and format_color == 'buy':
            count_str = "\033[34m" +  str(count) + "\033[0m"
        else:
            count_str = str(count)
        return count_str + "/" + str(total_rivals)
    
    @classmethod
    def lerp_color(self,color1, color2, weight):
        """Interpolate between two colors with a given weight."""
        r = (1 - weight) * color1[0] + weight * color2[0]
        g = (1 - weight) * color1[1] + weight * color2[1]
        b = (1 - weight) * color1[2] + weight * color2[2]
        return (r, g, b)

    @classmethod
    def get_gradient_color(self,value, min_val, med_val, max_val):
        if value < med_val:
            weight = (value - min_val) / (med_val - min_val)
            color1 = (0, 0.7, 0) # green
#             color2 = (1, 0.5, 0) # orange
            color2 = (0, 0, 1) # blue
            hex_string =  "#" + "".join("%02x" % round(c * 255) for c in self.lerp_color(color1, color2, weight))
        else:
            weight = (value - med_val) / (max_val - med_val)
            color1 = (0, 0, 1) # blue
#             color1 = (1, 0.5, 0) # yellow
            color2 = (1, 0, 0) # red
    #         color2 = (0, 0, 1) # blue
            hex_string = "#" + "".join("%02x" % round(c * 255) for c in self.lerp_color(color1, color2, weight))
    
        color = hex_string
        text = value
        colored_text = "\033[38;2;{};{};{}m{}\033[0m".format(
            int(color[1:3], 16), int(color[3:5], 16), int(color[5:], 16), text
        )
        return colored_text
    
    @classmethod
    def get_static_color(self,tuple_val, param):
        """
        Takes a value, minimum value, and maximum value and returns a
        background-color ANSI escape code for the cell based on the value's
        position between the minimum and maximum.
        """
        if isinstance(tuple_val, tuple):
            actual_vals = tuple_val[1]
            averaged_val = round(tuple_val[0],2)
            avg_str = str(averaged_val) + ": "
        elif isinstance(tuple_val, list):
            actual_vals = tuple_val
            avg_str = ""
        if param == 'ict':
            low_thr,mid_thr,high_thr = 3.5,5,7.5
        elif param == 'xGI':
            low_thr,mid_thr,high_thr = 0.2,0.5,0.9
        elif param == 'history':
            low_thr,mid_thr,high_thr = 4,6,9
        elif param == 'bps':
            low_thr,mid_thr,high_thr = 14,21,29
        elif param == 'minutes':
            low_thr,mid_thr,high_thr = 45,60,89
        val_str = ""
        for val in actual_vals:
            if val <= low_thr:
                color_code = '\033[1;31m'  # bold red
            elif val <= mid_thr:
                color_code = '\033[1;33m'  # bold yellow
            elif val <= high_thr:
                color_code = '\033[1;32m'  # bold green
            else:
                color_code = '\033[1;34m'  # bold blue
            val_str += color_code + str(round(val,2)) + ' \033[0m'
        return avg_str + val_str
    
    @classmethod
    def get_colored_fixtures(self,team_id, look_ahead, reference_gw=None):
        fdr_color_scheme = {
            1: (79, 121, 66),
            2: (51, 230, 153),
            3: (210, 210, 210),
            4: (255, 64, 107),
            5: (150, 27, 67)
        }

        fixturelist = GrabFunctions.player_fixtures('fwd',team_id,look_ahead, reference_gw)
        bgws,dgws = FixtureMath.look_for_blanks_and_dgws()
        dgws = list(dgws.keys())
        printstring = ''
        for gw in fixturelist:
            fixtures = gw[-1]
    #         printstring += '|'
            if fixtures:
                xtra = ''
                if len(fixtures) > 1:
                    spacing = ' '
                else:
                    if gw[0] in dgws:
                        spacing = '     '
                        xtra = ' '
                    else:
                        spacing = ' '
                for fixture in fixtures:
                    team,loc,fdr = fixture[1],fixture[2],fixture[3]
                    rgb_tuple = fdr_color_scheme[fdr]
                    printstring += f'\x1b[48;2;{rgb_tuple[0]};{rgb_tuple[1]};{rgb_tuple[2]}m{spacing}{team} ({loc}){spacing}{xtra}\x1b[0m'
            else:
                if gw[0] in dgws:
                    spacing = '        '
                else:
                    spacing = '    '
                printstring += f"\x1b[48;2;210;210;210m{spacing}-{spacing}\x1b[0m"
            printstring += ' '
        return printstring
 
    @classmethod
    def get_colored_teams(self,team_3ltr):
        team_colors = {
            'ARS': {'bg': (206, 78, 95), 'text': (255, 255, 255)},
            'AVL': {'bg': (133, 60, 83), 'text': (207, 200, 99)},
            'BOU': {'bg': (206, 75, 75), 'text': (0, 0, 0)},
            'BRE': {'bg': (255, 178, 180), 'text': (0, 0, 0)},
            'BHA': {'bg': (48, 76, 143), 'text': (255, 255, 255)},
            'BUR': {'bg': (210, 210, 210), 'text': (0, 0, 0)},
            'CHE': {'bg': (59, 89, 152), 'text': (255, 255, 255)},
            'CRY': {'bg': (155, 57, 98), 'text': (255, 255, 255)},
            'EVE': {'bg': (43, 76, 116), 'text': (255, 255, 255)},
            'FUL': {'bg': (105, 105, 105), 'text': (255, 255, 255)},
            'LIV': {'bg': (100, 210, 156), 'text': (193, 53, 81)},
            'LUT': {'bg': (51, 93, 158), 'text': (246, 205, 96)},
            'MCI': {'bg': (149, 200, 210), 'text': (0, 0, 0)},
            'MUN': {'bg': (195, 68, 75), 'text': (246, 205, 96)},
            'NEW': {'bg': (105, 105, 105), 'text': (255, 255, 255)},
            'NFO': {'bg': (195, 68, 75), 'text': (255, 255, 255)},
            'SHE': {'bg': (220, 220, 220), 'text': (220, 87, 103)},
            'TOT': {'bg': (64, 92, 138), 'text': (255, 255, 255)},
            'WHU': {'bg': (146, 72, 72), 'text': (255, 255, 255)},
            'WOL': {'bg': (246, 205, 96), 'text': (0, 0, 0)}
        }


        if team_3ltr in team_colors:
            bg_rgb_tuple = team_colors[team_3ltr]['bg']
            text_rgb_tuple = team_colors[team_3ltr]['text']
            colored_text = f'\x1b[38;2;{text_rgb_tuple[0]};{text_rgb_tuple[1]};{text_rgb_tuple[2]}m'
            colored_bg = f'\x1b[48;2;{bg_rgb_tuple[0]};{bg_rgb_tuple[1]};{bg_rgb_tuple[2]}m'
            reset_color = '\x1b[0m'
            formatted_string = f'{colored_bg}{colored_text} {team_3ltr} {reset_color}'
        else:
            formatted_string = team_3ltr
        return formatted_string

    @classmethod
    def get_past_fixtures_colors(self,team_id, look_behind):
        fdr_color_scheme = {
            1: (79, 121, 66),
            2: (51, 230, 153),
            3: (210, 210, 210),
            4: (255, 64, 107),
            5: (150, 27, 67)
        }

        fixturelist = GrabFunctions.player_fixtures('rev',team_id,look_behind)
        printstring = ''
        count = 0
        for gw in fixturelist:
            fixtures = gw[-1]
    #         printstring += '|'
            if fixtures:
                for fixture in fixtures:
                    if count < look_behind:
                        count += 1
                        fdr = fixture[3]
                        rgb_tuple = fdr_color_scheme[fdr]
                        printstring += f'\x1b[48;2;{rgb_tuple[0]};{rgb_tuple[1]};{rgb_tuple[2]}m  \x1b[0m'
            else:
#                 if count < look_behind:
#                     count += 1
#                     printstring += f"\x1b[48;2;0;0;0m  \x1b[0m"
                continue
        return printstring

    @classmethod
    def player_summary(self, dataset: str, values: list = None):
        net_spend_limit = round(MyTeam.bank_value,2)
        if dataset == 'custom':
            players = values
            player_ids = []
            for player in players:
                if isinstance(player, str):
                    found_plyr = DataPlotter.loop_name_finder(player)
                    if not found_plyr:
                        print(f'Empty entry, skipping player.')
                        continue
                    df = FPLDatabase.total_summary.loc[FPLDatabase.total_summary['player'] == str(found_plyr)]
                    player_ids.append(df.id_player.values[0])
                else:
                    player_ids.append(player)
            players = [x for x in self.players if x['id'] in player_ids]
            format_color = 'buy'
        elif dataset == 'FPL15':
            players = [x for x in self.players if x['id'] in MyTeam.df_fpl['id'].to_list()]
            format_color = 'sell'
        else:
            print("'dataset' variable must be one of 'FPL15' or 'custom'")
            return
        # Define function to apply color to each cell

        seq_map = {'GKP':0, 'DEF':1, 'MID':2, 'FWD':3}
        sorted_players = sorted(players, key=lambda x: (seq_map[x['position']], -x['history'][0]))
#         costs = sorted([x['cost'] for x in sorted_players])
        prev_position = None
    
        table_cols = ['FPL15 Player','Position','Team','Past FDRs','History','Bonus Points','ICT','xGI','Minutes','xGC','Cost','ð™¹ðš€ðš','ð™¶ðš‚ð™¿','â˜†â‚â‚–','â˜†â‚â‚€â‚–','â˜†â‚â‚€â‚€â‚–','â˜†','Upcoming Fixtures']
#         gen_cols = [x for x in DecisionMatrix.eff_own_dict.keys() if 'gen_' in str(x)]
        tab = PrettyTable(table_cols)
        for plyr_dict in sorted_players:
            cost = plyr_dict['cost']
            name = plyr_dict['name']
#             history = plyr_dict['history'][0]
#             bps = plyr_dict['bps'][0]
#             ict = plyr_dict['ict'][0]
            position = plyr_dict['position']
            team_id = GrabFunctions.grab_player_team_id(plyr_dict['id'])
            if prev_position:
                if prev_position != position:
                    tab.add_row(['']*len(table_cols))
            if position == 'DEF':
                tab.add_row([name,
                             position,
                             self.get_colored_teams(GrabFunctions.grab_3ltr_team_name(team_id)),
                             self.get_past_fixtures_colors(team_id,6),
                             self.get_static_color(plyr_dict['history'],'history'),
                             self.get_static_color(plyr_dict['bps'],'bps'),
                             self.get_static_color(plyr_dict['ict'],'ict'),
                             self.get_static_color(plyr_dict['xGI'],'xGI'),
                             self.get_static_color(plyr_dict['minutes'],'minutes'),
                             round(plyr_dict['xGC'][0],2),
                             self.get_gradient_color(cost,min(cost,3.8),7,max(cost,13)),
                             self.get_ownership(plyr_dict['id'],league_id=782655,format_color=format_color),
                             self.get_ownership(plyr_dict['id'],league_id=467038,format_color=format_color),
                             self.get_ownership(plyr_dict['id'],league_id='gen_1k',format_color=format_color),
                             self.get_ownership(plyr_dict['id'],league_id='gen_10k',format_color=format_color),
                             self.get_ownership(plyr_dict['id'],league_id='gen_100k',format_color=format_color),
                             self.get_ownership(plyr_dict['id'],league_id='genius',format_color=format_color),
                             self.get_colored_fixtures(GrabFunctions.grab_player_team_id(plyr_dict['id']),5)
#                              self.get_gradient_color(cost,min(costs),statistics.median(costs),max(costs))
                            ])
            else:
                tab.add_row([name,
                             position,
                             self.get_colored_teams(GrabFunctions.grab_3ltr_team_name(team_id)),
                             self.get_past_fixtures_colors(team_id,6),
                             self.get_static_color(plyr_dict['history'],'history'),
                             self.get_static_color(plyr_dict['bps'],'bps'),
                             self.get_static_color(plyr_dict['ict'],'ict'),
                             self.get_static_color(plyr_dict['xGI'],'xGI'),
                             self.get_static_color(plyr_dict['minutes'],'minutes'),
                             '-',
                             self.get_gradient_color(cost,min(cost,3.8),7,max(cost,13)),
                             self.get_ownership(plyr_dict['id'],league_id=782655,format_color=format_color),
                             self.get_ownership(plyr_dict['id'],league_id=467038,format_color=format_color),
                             self.get_ownership(plyr_dict['id'],league_id='gen_1k',format_color=format_color),
                             self.get_ownership(plyr_dict['id'],league_id='gen_10k',format_color=format_color),
                             self.get_ownership(plyr_dict['id'],league_id='gen_100k',format_color=format_color),
                             self.get_ownership(plyr_dict['id'],league_id='genius',format_color=format_color),
                             self.get_colored_fixtures(GrabFunctions.grab_player_team_id(plyr_dict['id']),5)
                            ])
            prev_position = position
        print(tab)
        
    @classmethod
    def replacement_summary(self, net_limit = True):
        #Single replacements
        net_spend_limit = round(MyTeam.bank_value,2)
        tab = PrettyTable(['FPL15 Player','Position','FPL15 ICT','FPL15 xGI','FPL15 xGC','Replacement','Team','Past FDRs','ICT','xGI','xGC','Net Spend','Upcoming Fixtures'])
        if net_limit:
            nets = [d[-1] for inner_dict in self.my_dict.values() for d in inner_dict['replacement'] if d[-1] <= net_spend_limit]
        else:
            nets = [d[-1] for inner_dict in self.my_dict.values() for d in inner_dict['replacement']]
#         prev_position,prev_FPL15_player_name = None, None
        for key in self.my_dict:
            FPL15_player_name = key
        #     print(f'Replace {key} with:')
            comp_dict = self.my_dict[key]
            replacements = comp_dict['replacement']
            sorted_replacements = sorted(replacements, key=lambda x: x[0]['history'][0], reverse=True)
            count = 0
            for r in sorted_replacements:
                #FP15 Player
                position = comp_dict['stats']['position']
#                 print(f'{position} {prev_position}')
#                 position = r[0]['position']
                #Replacements
                name = r[0]['name']
                team_id = GrabFunctions.grab_player_team_id(r[0]['id'])
                ict = r[0]['ict']
                net = r[-1]
                if net_limit:
                    cond = (net <= net_spend_limit)
                else:
                    cond = True
                if cond:
#                     print(position)
                    if count == 0:
                        tab.add_row(['']*13)
                        FPL15_ICT = self.get_static_color(comp_dict['stats']['ict'],'ict')
                        FPL15_xGI = self.get_static_color(comp_dict['stats']['xGI'],'xGI')
                        if position == 'DEF':
                            FPL15_xGC = round(comp_dict['stats']['xGC'][0],2)
                        FPL15_pos = position
                    else:
#                         if prev_FPL15_player_name == FPL15_player_name:
                        FPL15_player_name, FPL15_pos, FPL15_ICT, FPL15_xGI, FPL15_xGC = '','','','',''
#                     if prev_position:
#                         if prev_position != position:
# #                             print(f'{prev_position} {position}')
#                             tab.add_row(['']*13)
        #             print(f' - {name}  |  {round(ict,2)}  |  Net Spend: {round(net,2)} $')
                    count += 1
                    if position == 'DEF':
                        tab.add_row([FPL15_player_name,
                                     FPL15_pos,
                                     FPL15_ICT,
                                     FPL15_xGI,
                                     FPL15_xGC,
                                     name,
                                     self.get_colored_teams(GrabFunctions.grab_3ltr_team_name(team_id)),
                                     self.get_past_fixtures_colors(team_id,6),
                                     self.get_static_color(r[0]['ict'],'ict'),
                                     self.get_static_color(r[0]['xGI'],'xGI'),
                                     round(r[0]['xGC'][0],2),
                                     self.get_gradient_color(net,min(nets),0,max(nets)),
                                     self.get_colored_fixtures(GrabFunctions.grab_player_team_id(r[0]['id']),5)])
                    else:
                        tab.add_row([FPL15_player_name,
                                     FPL15_pos,
                                     FPL15_ICT,
                                     FPL15_xGI,
                                     '-',
                                     name,
                                     self.get_colored_teams(GrabFunctions.grab_3ltr_team_name(team_id)),
                                     self.get_past_fixtures_colors(team_id,6),
                                     self.get_static_color(r[0]['ict'],'ict'),
                                     self.get_static_color(r[0]['xGI'],'xGI'),
                                     '-',
                                     self.get_gradient_color(net,min(nets),0,max(nets)),
                                     self.get_colored_fixtures(GrabFunctions.grab_player_team_id(r[0]['id']),5)])
#                     if FPL15_player_name and position:
#                         prev_position,prev_FPL15_player_name = position,FPL15_player_name
        tab.align["Upcoming Fixtures"] = "l"
        print(tab)
        
DecisionMatrix.initialize_players()
DecisionMatrix.initialize_replacements()
DecisionMatrix.initialize_effective_ownership()